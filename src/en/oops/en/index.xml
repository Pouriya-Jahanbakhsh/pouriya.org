<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeFather</title>
    <link>https://pouriya.org/en/</link>
    <description>Recent content on CodeFather</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2019 Â© Pouriya Jahanbakhsh</copyright>
    <lastBuildDate>Wed, 20 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://pouriya.org/en/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Erlang behaviors in Python</title>
      <link>https://pouriya.org/en/posts/erlang-behaviors-in-python/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://pouriya.org/en/posts/erlang-behaviors-in-python/</guid>
      <description>Since python is an OOP (Object Oriented Programming) language; As a Python programmer you often work with classes, objecst, inheritance, etc and they make sense to you. But what happens when you start coding in a pure functional programming language like Erlang? One important problem is that you don&amp;rsquo;t see class keyword or something like that to implement your own abstraction layers. So how do Erlangers separate generic parts of code from specefic parts?</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://pouriya.org/en/about/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0330</pubDate>
      
      <guid>https://pouriya.org/en/about/</guid>
      <description>class About: def name(self): return &amp;#34;Pouriya Jahanbakhsh&amp;#34; def job(self): return &amp;#34;Software Programmer&amp;#34; def programming_languages(self): # The ability to get things done # min: 1 &amp;amp; max: 5 return { &amp;#34;Erlang/OTP&amp;#34;: 5, &amp;#34;Python&amp;#34;: 4, &amp;#34;AWK&amp;#34;: 4, &amp;#34;C&amp;#34;: 3, &amp;#34;Elixir&amp;#34;: 3, &amp;#34;Sh&amp;#34;: 3, &amp;#34;Ruby&amp;#34;: 2, &amp;#34;Perl&amp;#34;: 1, &amp;#34;Go&amp;#34;: 1, &amp;#34;Rust&amp;#34;: 1 } def operating_systems(self): return {&amp;#34;FreeBSD&amp;#34;: 4, &amp;#34;GNU/Linux&amp;#34;: 3} def databases(self): return { &amp;#34;Cassandra&amp;#34;: 3, &amp;#34;Influxdb&amp;#34;: 3, &amp;#34;MySQL&amp;#34;: 3, &amp;#34;MariaDB&amp;#34;: 3 } def message_brokers(self): return { &amp;#34;Ejabberd&amp;#34;: 5, &amp;#34;MongooseIM&amp;#34;: 3, &amp;#34;Kafka&amp;#34;: 3 } def techinal_skills(self): return { &amp;#34;Functional programming&amp;#34;: 4, &amp;#34;Socket programming&amp;#34;: 4, &amp;#34;Test Driven Development&amp;#34;: 4, &amp;#34;Monitoring&amp;#34;: 3 } def country(self): return &amp;#34;Iran&amp;#34; def email(self): return &amp;#34;pouriya.</description>
    </item>
    
    <item>
      <title>Contributions</title>
      <link>https://pouriya.org/en/contributions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pouriya.org/en/contributions/</guid>
      <description>Erlang/OTP I Fixed a bug in stdlib&amp;rsquo;s sys module and added a new feature to it. Link to Pull-Request
 
Ejabberd I added a new hook to detect XMPP&amp;rsquo;s component packets. Link to Pull-Request  
Warp (self-contained single binary maker) I added a complete Erlang example. Link to Pull-Request  
InfluxDB client line encoder Link to Repository  
OpenTSDB telnet encoder Link to Repository</description>
    </item>
    
    <item>
      <title>OSS</title>
      <link>https://pouriya.org/en/oss/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pouriya.org/en/oss/</guid>
      <description>I do love coding things and especially building OSS (Open-Source Software).
EMeter  Fast and pluginable monitoring tool for Erlang ecosystem. 
director  Director is a production-ready supervisor and manager for Erlang/Elixir processes that focuses on speed, performance and flexibility.
tir  Have time.ir in shell!
sockerl  Sockerl is an Erlang/Elixir socket framework for TCP protocols and provides fast, useful and easy-to-use API for implementing servers, clients and client connection pools.</description>
    </item>
    
  </channel>
</rss>